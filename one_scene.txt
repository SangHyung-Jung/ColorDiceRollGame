🛠️ Color Dice Roll Game - Single-Scene Architecture Refactoring Plan
1. 프로젝트 목표 (Project Goal)
기존의 분리된 씬 전환 방식(get_tree().change_scene_to_file)을 폐기하고, 최상위 단일 씬(GameRoot.tscn) 체제로 전환한다. 로딩 없이 부드러운 카메라 이동(Tween)을 통해 "게임 플레이 구역"과 "상점 구역"을 오가며 몰입도를 극대화한다.

2. 아키텍처 설계 (Architecture Design)
2.1. 새로운 노드 트리 구조 (New Node Tree)
새로 생성할 GameRoot.tscn의 구조입니다. 기존 MainScreen의 SubViewport 구조는 폐기합니다.

Plaintext

GameRoot (Node3D) - 최상위 노드, GameRoot.gd 스크립트 연결
 ├── WorldEnvironment (조명 및 환경 설정)
 ├── DirectionalLight3D
 ├── MainCamera (Camera3D) - 유일한 카메라, 스크립트로 위치 이동 제어
 ├── 3D_World (Node3D) - 3D 오브젝트 컨테이너
 │    ├── PlayArea (Node3D) - 위치: Vector3(0, 0, 0)
 │    │    └── RollingWorld (기존 rolling_world.tscn 인스턴스)
 │    └── ShopArea (Node3D) - 위치: Vector3(20, 0, 0)
 │         └── (상점 3D 모델들 배치 - 책상, 선반 등)
 │
 ├── Managers (Node) - 씬 내장 매니저들 (선택사항, Autoload로 대체 가능)
 │    ├── GameManager
 │    └── ScoreManager
 │
 └── UI_Canvas (CanvasLayer) - UI 최상위 레이어
      ├── GameHUD (Control) - 기존 main_screen.tscn의 UI 요소들
      └── ShopHUD (Control) - 기존 shop_screen.tscn의 UI 요소들
3. 단계별 구현 명세 (Step-by-Step Implementation Guide)
Phase 1: 3D 환경 및 카메라 통합
작업 내용:

scenes/game_root.tscn (Node3D) 생성.

MainCamera 추가. 현재 뷰를 게임 테이블(PlayArea)이 잘 보이도록 초기 위치(예: Vector3(0, 15, 0))와 각도(예: rotation_degrees.x = -90) 설정.

scenes/rolling_world.tscn을 PlayArea의 자식으로 인스턴스화.

ShopArea 노드를 Vector3(20, 0, 0) 위치에 생성.

Phase 2: UI 디커플링 (SubViewport 제거)
작업 내용:

기존 main_screen.tscn에서 SubViewportContainer와 SubViewport를 제거. UI(Control 노드들)만 남겨 scenes/components/game_hud.tscn으로 저장.

기존 shop_screen.tscn의 UI 요소만 분리하여 scenes/components/shop_hud.tscn으로 저장.

두 HUD 씬을 GameRoot의 UI_Canvas 하위에 배치.

Phase 3: GameRoot.gd 카메라 컨트롤러 작성
작업 내용: GameRoot.gd 스크립트를 작성하여 카메라 이동과 UI 토글 로직을 구현.

명세 코드 (GameRoot.gd):

GDScript

extends Node3D

@onready var camera = $MainCamera
@onready var game_hud = $UI_Canvas/GameHUD
@onready var shop_hud = $UI_Canvas/ShopHUD

const POS_GAME = Vector3(0, 15, 0) # 게임 플레이 카메라 위치
const POS_SHOP = Vector3(20, 15, 0) # 상점 카메라 위치

const ROT_GAME = Vector3(-90, 0, 0)
const ROT_SHOP = Vector3(-45, 0, 0) # 상점은 비스듬히 보는 뷰 (예시)

func _ready():
    # 게임 시작 시 게임 화면으로 초기화
    transition_to_game(true)
    
    # UI에서 발생하는 시그널 연결
    game_hud.connect("go_to_shop_requested", Callable(self, "transition_to_shop"))
    shop_hud.connect("go_to_game_requested", Callable(self, "transition_to_game"))

func transition_to_shop():
    # UI 즉시 전환 방지: 이동 시작 시 게임 UI 숨김
    game_hud.visible = false 
    
    var tween = create_tween().set_parallel(true)
    tween.set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_IN_OUT)
    tween.tween_property(camera, "global_position", POS_SHOP, 1.5)
    tween.tween_property(camera, "rotation_degrees", ROT_SHOP, 1.5)
    
    tween.chain().tween_callback(func():
        shop_hud.visible = true
        shop_hud.enter_shop_sequence() # 상점 진입 애니메이션/로직 실행
    )

func transition_to_game(instant: bool = false):
    shop_hud.visible = false
    
    if instant:
        camera.global_position = POS_GAME
        camera.rotation_degrees = ROT_GAME
        game_hud.visible = true
        return

    var tween = create_tween().set_parallel(true)
    tween.set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_IN_OUT)
    tween.tween_property(camera, "global_position", POS_GAME, 1.5)
    tween.tween_property(camera, "rotation_degrees", ROT_GAME, 1.5)
    
    tween.chain().tween_callback(func():
        game_hud.visible = true
        game_hud.start_round_sequence() # 게임 라운드 시작 로직
    )
Phase 4: 기존 스크립트 리팩토링 (Signal 기반 전환)
기존의 change_scene_to_file 코드를 모두 제거하고 상위 GameRoot로 Signal을 보내도록 수정.

1. game_hud.gd (기존 main_screen.gd) 수정:

상단에 signal go_to_shop_requested 선언 추가.

라운드 클리어/쇼핑 버튼 클릭 시:

GDScript

# 기존 코드: get_tree().change_scene_to_file("res://shop_screen.tscn")
# 변경 코드:
func _on_go_to_shop_button_pressed():
    emit_signal("go_to_shop_requested")
2. shop_hud.gd (기존 shop_screen.gd) 수정:

상단에 signal go_to_game_requested 선언 추가.

다음 라운드 버튼 클릭 시:

GDScript

# 기존 코드: get_tree().change_scene_to_file("res://main_screen.tscn")
# 변경 코드:
func _on_next_round_button_pressed():
    StageManager.advance_to_next_round() # 스테이지 증가
    emit_signal("go_to_game_requested")
Phase 5: Raycast 및 3D 상호작용 업데이트
작업 내용: 기존에 MainCamera가 SubViewport 내부에 있어서 마우스 클릭 좌표 변환이 필요했을 수 있습니다. 이제 최상위 노드의 MainCamera를 사용하므로, 주사위 클릭 등을 처리하는 Raycast 로직을 업데이트해야 합니다.

RollingWorld.gd 또는 InputManager가 3D 오브젝트를 클릭할 때, get_viewport().get_camera_3d()가 이제 GameRoot의 MainCamera를 정확히 참조하도록 확인.

Phase 6: 메모리 및 데이터 유지 (Global State)
작업 내용: 단일 씬 구조에서는 노드가 삭제되지 않으므로, 데이터가 누적될 수 있습니다.

라운드 재시작 시 game_hud.gd의 start_round_sequence() 함수에서 주사위 초기화, 점수판 초기화 등을 명시적으로 호출해야 합니다.

4. 에이전트 체크리스트 (Definition of Done)
[ ] GameRoot.tscn이 프로젝트의 메인 씬(Project Settings > Run > Main Scene)으로 설정되었는가?

[ ] GameRoot 내에 WorldSpace(3D)와 UI_Canvas(2D)가 명확히 분리되었는가?

[ ] Tween을 이용한 부드러운 카메라 워크가 1.5초 동안 작동하는가?

[ ] 게임에서 상점 이동 시: 게임 UI 숨김 -> 카메라 이동 -> 상점 UI 표시 순서가 지켜지는가?

[ ] 상점에서 게임 복귀 시: 상점 UI 숨김 -> 카메라 이동 -> 게임 UI 표시 순서가 지켜지는가?

[ ] 프로젝트 내에서 get_tree().change_scene_to_file() 함수가 완전히 제거되었는가?

[ ] 기존의 SubViewport 관련 노드들이 모두 정리되었는가?

5. 실행 프롬프트 가이드 (Agent Prompt)
"이 마스터 플랜을 바탕으로 코드 리팩토링을 시작하세요. Phase 1부터 차례대로 진행하며, GameRoot.gd를 생성하고 기존 main_screen.gd와 shop_screen.gd의 씬 전환 코드를 시그널 방식으로 교체하십시오. 3D 노드와 UI 노드를 완전히 분리하는 것이 핵심입니다."